let walls = [];
let robot;
let persistentPoints = [];
let showWalls = false;
let showPersistent = false;
let resolutionSlider;
let lidarModeButton;

let algoSelect; // <select> DOM
let currentAlgo = "";

// FPS 측정
let lastTime = 0;
let avgFPS = 0;
let frameCount = 0;

// 오차(RMSE) 측정
let sumSquaredError = 0;
let numErrorSamples = 0;

// 전력 추정
let basePower = 5;
let rayCost = 0.05;
let pfCost = 0.3;
let icpCost = 0.6; 
let estimatedPower = 0;

// 메모리 제한
let maxPersistentPoints = 3000;

// 데이터 로그
let dataLog = [];

// CSV Export 버튼
let exportButton;

////////////////////////////////////////////////////////////////

let simWidth = 600;       // 왼쪽 시뮬레이션 영역
let graphWidth = 600;     // 오른쪽 그래프 영역

//////////////////////////////////////////////////////////////////




/***************************************************
 * [자동 이동/자동 실험 실행 관련]
 ***************************************************/
let autoMove = true;           
let testDuration = 150000;  // 2분 30초
let startTime = 0;             
let movePhase = 0;             
let phaseTime = 0;             

// [자동 실험] 해상도/알고리즘 순차 실행
let autoExperiment = true;     
let resolutions = [1, 5, 10, 15];

// let algorithms = ['DR', 'KF', 'PF', 'ICP/GraphSLAM'];
let algorithms = ['PF'];

let experimentList = [];
let currentExperimentIndex = 0;

//////////////////////////////////////////////////////////////////////////////////////////

// ------------------ 2) RMSE 관련 전역 상수 & 자료구조 -------------
const WINDOW_SIZE = 30;
const WARMUP_FRAMES = 50;
const EXP_ALPHA = 0.1;

// window배열 & warm-up배열
let windowArrays = {
  "dr_posHeading": [],
  "dr_distanceRatio": [],
  "kf_mahalanobis": [],
  "pf_median": [],
  "pf_best": [],
  "icp_residual": []
};

let warmupExpState = {
  "dr_posHeading": { frameCount:0, expMeanSq:0 },
  "dr_distanceRatio": { frameCount:0, expMeanSq:0 },
  "kf_mahalanobis": { frameCount:0, expMeanSq:0 },
  "pf_median": { frameCount:0, expMeanSq:0 },
  "pf_best": { frameCount:0, expMeanSq:0 },
  "icp_residual": { frameCount:0, expMeanSq:0 }
};

//////////////////////////////////////////////////////////////////////////////////////////

// -------------------------------------------------------------
function buildExperimentList() {
  for (let r of resolutions) {
    for (let a of algorithms) {
      experimentList.push({res: r, algo: a});
    }
  }
}

// -------------------------------------------------------------
function setup() {

  createCanvas(simWidth + graphWidth, 600); /////////////////////////////////////////////////////////////////////////////////////////////////////

  // 항상 동일한 벽 랜덤시드를 위해
  randomSeed(0);

  // (1) 사각형 테두리 (전체 캔버스 경계)
  walls.push(new Boundary(0, 0, simWidth, 0));
  walls.push(new Boundary(simWidth, 0, simWidth, height));
  walls.push(new Boundary(simWidth, height, 0, height));
  walls.push(new Boundary(0, height, 0, 0));


  // (2) 내부에 3개 랜덤 벽
  for (let i = 0; i < 5; i++) {
    let x1 = random(50, simWidth - 50);
    let y1 = random(50, height - 50);
    let x2 = random(50, simWidth - 50);
    let y2 = random(50, height - 50);
    walls.push(new Boundary(x1, y1, x2, y2));
  }

  robot = new Robot(width / 4, height / 2);

  let toggleButton = createButton('Toggle Walls');
  toggleButton.position(10, 10);
  toggleButton.mousePressed(() => (showWalls = !showWalls));

  lidarModeButton = createButton('Toggle Persistent LiDAR (SLAM)');
  lidarModeButton.position(120, 10);
  lidarModeButton.mousePressed(() => (showPersistent = !showPersistent));

  resolutionSlider = createSlider(1, 15, 1, 1);
  resolutionSlider.position(360, 10);

  // 알고리즘 선택 Select
  algoSelect = createSelect();
  algoSelect.position(520, 10);
  algoSelect.option('Select Algorithm');
  algoSelect.option('DR');
  algoSelect.option('KF');
  algoSelect.option('PF');
  algoSelect.option('ICP/GraphSLAM');
  algoSelect.changed(() => {
    let newAlgo = algoSelect.value();
    if (newAlgo === 'Select Algorithm') return;

    if (currentAlgo !== "" && currentAlgo !== newAlgo && dataLog.length > 0) {
      exportCSV();
      resetSimulation();
    }
    currentAlgo = newAlgo;
  });

  exportButton = createButton('Export CSV');
  exportButton.position(700, 10);
  exportButton.mousePressed(exportCSV);

  startTime = millis();
  buildExperimentList();
  if (autoExperiment && experimentList.length > 0) {
    applyExperimentParameters(0);
  }
}

// ------------------------------------------------------------
function draw() {
  background(30);

  // FPS
  let now = performance.now();
  let delta = now - lastTime;
  lastTime = now;
  frameCount++;
  let instFPS = 1000 / (delta || 1);
  if (frameCount === 1) {
    avgFPS = instFPS;
  } else {
    avgFPS = 0.9 * avgFPS + 0.1 * instFPS;
  }

  // 실험 시간 경과 체크
  if (millis() - startTime > testDuration) {
    exportCSV();
    nextExperiment(); 
    return;
  }

  // 벽 표시
  if (showWalls) {
    push();
    for (let wall of walls) {
      wall.show();
    }
    pop();
  }

  robot.update(delta);
  let currentPoints = robot.look(walls);
  robot.show();

  // LiDAR 점
  fill(255, 0, 0);
  noStroke();
  for (let p of currentPoints) {
    ellipse(p.x, p.y, 5);
    if (showPersistent) {
      persistentPoints.push(p.copy());
    }
  }

  if (persistentPoints.length > maxPersistentPoints) {
    persistentPoints.splice(0, persistentPoints.length - maxPersistentPoints);
  }
  if (showPersistent) {
    fill(255, 100, 100, 80);
    noStroke();
    for (let p of persistentPoints) {
      ellipse(p.x, p.y, 3);
    }
  }

  // 알고리즘 추정 업데이트
  robot.updateEstimation(currentAlgo, delta, currentPoints);

//   // RMSE (pos vs estimatedPos)
//   let dx = robot.pos.x - robot.estimatedPos.x;
//   let dy = robot.pos.y - robot.estimatedPos.y;
//   let distSq = dx*dx + dy*dy;
//   sumSquaredError += distSq;
//   numErrorSamples++;
//   let rmse = sqrt(sumSquaredError/(numErrorSamples||1));

  ///////////////////////////////////////////////////////////////////////////////////////////////////

  // ---- 기존 pos vs estPos RMSE (단순)
  let dx = robot.pos.x - robot.estimatedPos.x;
  let dy = robot.pos.y - robot.estimatedPos.y;
  let distSq = dx*dx + dy*dy;
  sumSquaredError += distSq;
  numErrorSamples++;
  let basicRMSE = sqrt(sumSquaredError/(numErrorSamples || 1));

  // 전력 추정
  let numRays = robot.rays.length;
  estimatedPower = basePower + numRays*rayCost;
  if (currentAlgo==='PF') {
    estimatedPower += pfCost*numRays;
  } else if (currentAlgo==='ICP/GraphSLAM') {
    estimatedPower += icpCost*numRays;
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////

  // (A) 알고리즘별 RMSE 업데이트 (window & warm-up)
  let rmseObj = updateRMSETrackers(currentAlgo);

  // headingErr, kfTraceP, pfVariance, icpPairCount
  let headingErr = 0;
  if (currentAlgo==='KF' && robot.kf) {
    headingErr = angleDiff(robot.heading, robot.kf.theta);
  }
  else if (currentAlgo==='PF' && robot.particles) {
    let sumCos=0, sumSin=0;
    for(let p of robot.particles){ sumCos+= Math.cos(p.theta); sumSin+= Math.sin(p.theta); }
    let avgTheta = Math.atan2(sumSin,sumCos);
    headingErr = angleDiff(robot.heading, avgTheta);
  }
  else if (currentAlgo==='ICP/GraphSLAM') {
    headingErr = angleDiff(robot.heading, 0); 
  }
  else {
    headingErr = angleDiff(robot.heading, 0);
  }

  let kfTraceP= 0;
  if (currentAlgo==='KF' && robot.kf) {
    let P= robot.kf.P;
    kfTraceP = P[0][0] + P[1][1] + P[2][2];
  }

  let pfVariance= 0;
  if (currentAlgo==='PF' && robot.particles) {
    let sx=0, sy=0, n= robot.particles.length;
    for(let p of robot.particles){ sx+= p.x; sy+= p.y; }
    let mx= sx/n, my= sy/n;
    let sumv=0;
    for(let p of robot.particles){
      let dx= p.x-mx, dy= p.y-my;
      sumv+= (dx*dx + dy*dy);
    }
    pfVariance= sumv/(n||1);
  }

  let icpPairCount= (robot.tmpICPInlierCount || 0);


  ///////////////////////////////////////////////////////////////////////////////////////////////////


  // (B) dataLog push -> 12개 열
  dataLog.push({
    frame: frameCount,
    fps: avgFPS,
    rmse: basicRMSE,
    power: estimatedPower,
    resolution: resolutionSlider.value(),
    algo: currentAlgo,

    trueX: robot.pos.x,
    trueY: robot.pos.y,
    trueHeading: robot.heading,
    estX: robot.estimatedPos.x,
    estY: robot.estimatedPos.y,
    headingError: headingErr,
    kfTraceP: kfTraceP,
    pfVariance: pfVariance,
    icpPairCount: icpPairCount,

    // 12개 열
    dr_rmse_posHeading_window: rmseObj.dr_rmse_posHeading_window,
    dr_rmse_posHeading_warmup: rmseObj.dr_rmse_posHeading_warmup,
    dr_rmse_distanceRatio_window: rmseObj.dr_rmse_distanceRatio_window,
    dr_rmse_distanceRatio_warmup: rmseObj.dr_rmse_distanceRatio_warmup,

    kf_rmse_mahalanobis_window: rmseObj.kf_rmse_mahalanobis_window,
    kf_rmse_mahalanobis_warmup: rmseObj.kf_rmse_mahalanobis_warmup,

    pf_rmse_median_window: rmseObj.pf_rmse_median_window,
    pf_rmse_median_warmup: rmseObj.pf_rmse_median_warmup,
    pf_rmse_best_window: rmseObj.pf_rmse_best_window,
    pf_rmse_best_warmup: rmseObj.pf_rmse_best_warmup,

    icp_rmse_icpResidual_window: rmseObj.icp_rmse_icpResidual_window,
    icp_rmse_icpResidual_warmup: rmseObj.icp_rmse_icpResidual_warmup
  });

  // ---- 좌측 상단 ----
  // 화면 표시
  fill(255);
  textSize(14);
  text(`FPS (avg): ${avgFPS.toFixed(2)}`, 10, 50);
  text(`Algo Mode: ${currentAlgo}`, 10, 70);
  text(`Resolution: ${resolutionSlider.value()}`, 10, 90);
  text(`Basic RMSE: ${basicRMSE.toFixed(2)}`, 10, 110);
  text(`Power: ${estimatedPower.toFixed(2)}`, 10, 130);

//////////////////////////////////////////////////////////////////////////

  // (C) 오른쪽 영역에 RMSE 그래프
  //   "rmse" 라벨을 real-time line chart
  //   예: x=620, y=20, w=560, h=250
  // 시뮬레이션 영역이 600px인 경우라도, 그래프 영역의 너비를 작게 설정하고 시작 위치를 조정
  drawRMSEChart(simWidth + 20, 300, graphWidth - 40, 250, dataLog, "rmse");




}

//////////////////////////////////////////////////////////////////////////////////////////////


// ------------------ RMSE chart 함수 ------------------
function drawRMSEChart(x, y, w, h, dataArray, property) {
    push();
    translate(x, y);
  
    // 배경 그리기
    fill(60);
    noStroke();
    rect(0, 0, w, h);
  
    // dataArray에서 현재 property 값들의 최대값을 계산 (여기서는 기본값으로 200보다 크면 동적 조정)
    let maxData = dataArray.reduce((acc, cur) => Math.max(acc, cur[property]), 0);
    let maxVal = maxData > 200 ? maxData * 1.2 : 200;
    let minVal = 0;
  
    stroke(200);
    strokeWeight(2);
    noFill();
    beginShape();
    for (let i = 0; i < dataArray.length; i++) {
      let px = map(i, 0, dataArray.length - 1, 0, w);
      let py = map(dataArray[i][property], minVal, maxVal, h, 0);
      vertex(px, py);
    }
    endShape();
  
    fill(255);
    noStroke();
    textSize(12);
    text("RMSE (pos vs est)", 5, 15);
    pop();
}



/////////////////////////////////////////////////////////////////////////////////


// ------------------ 5) updateRMSETrackers() 함수 ------------------
function updateRMSETrackers(algo) {
    // raw errors (각 알고리즘에 따라 최대 2개 or 1개)
    let drPos=0, drDist=0;
    let kfMahal=0;
    let pfMed=0, pfBest=0;
    let icpRes=0;
  
    // --- 1) raw error 계산 ---
    switch(algo){
      case 'DR':
        // 두 가지 동시 계산
        drPos = computeDRPosHeadingError(robot);
        drDist= computeDRDistanceRatioError(robot);
        // window + warm-up
        updateWindowArray("dr_posHeading", drPos);
        updateWindowArray("dr_distanceRatio", drDist);
        updateWarmupExp("dr_posHeading", drPos, frameCount);
        updateWarmupExp("dr_distanceRatio", drDist, frameCount);
        break;
  
      case 'KF':
        kfMahal= computeKFmahalanobisError(robot);
        updateWindowArray("kf_mahalanobis", kfMahal);
        updateWarmupExp("kf_mahalanobis", kfMahal, frameCount);
        break;
  
      case 'PF':
        // median, best 둘다
        pfMed= computePFmedianError(robot);
        pfBest= computePFbestError(robot);
        updateWindowArray("pf_median", pfMed);
        updateWindowArray("pf_best", pfBest);
        updateWarmupExp("pf_median", pfMed, frameCount);
        updateWarmupExp("pf_best", pfBest, frameCount);
        break;
  
      case 'ICP/GraphSLAM':
        icpRes= computeICPResidualError(robot);
        updateWindowArray("icp_residual", icpRes);
        updateWarmupExp("icp_residual", icpRes, frameCount);
        break;
    }
  
    // --- 2) RMS(window) & RMS(warm-up) ---
    let drPosWin= computeWindowRMS("dr_posHeading");
    let drPosExp= computeWarmupExpRMS("dr_posHeading");
    let drDistWin= computeWindowRMS("dr_distanceRatio");
    let drDistExp= computeWarmupExpRMS("dr_distanceRatio");
  
    let kfMahalWin= computeWindowRMS("kf_mahalanobis");
    let kfMahalExp= computeWarmupExpRMS("kf_mahalanobis");
  
    let pfMedWin= computeWindowRMS("pf_median");
    let pfMedExp= computeWarmupExpRMS("pf_median");
    let pfBestWin= computeWindowRMS("pf_best");
    let pfBestExp= computeWarmupExpRMS("pf_best");
  
    let icpResWin= computeWindowRMS("icp_residual");
    let icpResExp= computeWarmupExpRMS("icp_residual");
  
    // 리턴해서 draw()에서 dataLog 저장 시 사용
    return {
      dr_rmse_posHeading_window: drPosWin,
      dr_rmse_posHeading_warmup: drPosExp,
      dr_rmse_distanceRatio_window: drDistWin,
      dr_rmse_distanceRatio_warmup: drDistExp,
  
      kf_rmse_mahalanobis_window: kfMahalWin,
      kf_rmse_mahalanobis_warmup: kfMahalExp,
  
      pf_rmse_median_window: pfMedWin,
      pf_rmse_median_warmup: pfMedExp,
      pf_rmse_best_window: pfBestWin,
      pf_rmse_best_warmup: pfBestExp,
  
      icp_rmse_icpResidual_window: icpResWin,
      icp_rmse_icpResidual_warmup: icpResExp
    };
  }
  
  // ------------------ 6) RMSE 계산 함수 6개 ------------------
  
  // DR posHeading
  function computeDRPosHeadingError(robot){
    let distPos = dist(robot.pos.x, robot.pos.y, robot.estimatedPos.x, robot.estimatedPos.y);
    // heading은 그냥 0과의 차이라 가정(혹은 robot.heading과 estimatedHeading 차이)
    let headDif = angleDiff(robot.heading, 0);
    return sqrt(distPos*distPos + headDif*headDif);
  }
  function computeDRDistanceRatioError(robot){
    let distPos = dist(robot.pos.x, robot.pos.y, robot.estimatedPos.x, robot.estimatedPos.y);
    // 가령 로봇의 누적이동거리 tracked… 여기선 임시로 1
    // 실제라면 robot 누적 이동거리 변수를 추가
    let traveled = robot.traveledDist || 1;
    return distPos / traveled;
  }
  
  // KF mahalanobis
  function computeKFmahalanobisError(robot){
    if(!robot.kf) return 0;
    let dx = robot.pos.x - robot.kf.x;
    let dy = robot.pos.y - robot.kf.y;
    // 2x2만 떼서 계산 (x,y)
    let P2 = [
      [robot.kf.P[0][0], robot.kf.P[0][1]],
      [robot.kf.P[1][0], robot.kf.P[1][1]]
    ];
    let invP2 = invert2x2(P2);
    return mahal2D(dx, dy, invP2);
  }
  
  // PF median, best
  function computePFmedianError(robot){
    if(!robot.particles || robot.particles.length<1) return 0;
    let xs= robot.particles.map(p=>p.x).sort((a,b)=>a-b);
    let ys= robot.particles.map(p=>p.y).sort((a,b)=>a-b);
    let mid = floor(xs.length/2);
    return dist(robot.pos.x, robot.pos.y, xs[mid], ys[mid]);
  }
  function computePFbestError(robot){
    if(!robot.particles || robot.particles.length<1) return 0;
    let bestW=-1, bx=0, by=0;
    for(let p of robot.particles){
      if(p.weight>bestW){ bestW=p.weight; bx=p.x; by=p.y; }
    }
    return dist(robot.pos.x, robot.pos.y, bx, by);
  }
  
  // ICP residual
  function computeICPResidualError(robot){
    if(robot.tmpICPResidualAvg != null){
      return robot.tmpICPResidualAvg;
    } else {
      // fallback => pos vs estPos
      return dist(robot.pos.x, robot.pos.y, robot.estimatedPos.x, robot.estimatedPos.y);
    }
  }
  
  // ------------------ 7) Window & warm-up 함수 ------------------
  function updateWindowArray(key, val){
    if(val<=0) return;
    if(!windowArrays[key]) return;
    windowArrays[key].push(val*1.0);
    if(windowArrays[key].length> WINDOW_SIZE){
      windowArrays[key].shift();
    }
  }
  function computeWindowRMS(key){
    if(!windowArrays[key] || windowArrays[key].length===0) return 0;
    let arr= windowArrays[key];
    let sum=0;
    for(let x of arr){
      sum+= x*x;
    }
    return sqrt(sum / arr.length);
  }
  
  function updateWarmupExp(key, val, frameNum){
    if(!warmupExpState[key]) return;
    let st= warmupExpState[key];
    if(frameNum<= WARMUP_FRAMES) {
      return; // warm-up중
    }
    st.frameCount++;
    let sq= val*val;
    if(st.expMeanSq===0) st.expMeanSq= sq;
    else st.expMeanSq= (1-EXP_ALPHA)* st.expMeanSq + EXP_ALPHA* sq;
  }
  function computeWarmupExpRMS(key){
    if(!warmupExpState[key]) return 0;
    let st= warmupExpState[key];
    if(st.frameCount<1) return 0;
    return sqrt(st.expMeanSq);
  }
  
  // ------------------ 8) 수학 유틸 (2x2 invert, mahal) ------------------
  function invert2x2(M){
    let det= M[0][0]* M[1][1] - M[0][1]*M[1][0];
    if(abs(det)<1e-9) return [[99999,0],[0,99999]];
    return [
      [ M[1][1]/det, -M[0][1]/det ],
      [ -M[1][0]/det, M[0][0]/det ]
    ];
  }
  function mahal2D(dx, dy, invP){
    let tx= invP[0][0]*dx + invP[0][1]*dy;
    let ty= invP[1][0]*dx + invP[1][1]*dy;
    return sqrt(dx*tx + dy*ty);
  }
  
  // angleDiff (already in code)
  function angleDiff(a, b){
    let d= (a-b) % (2*PI);
    if(d>PI) d-= 2*PI;
    if(d< -PI) d+= 2*PI;
    return d;
  }
  
  // ------------------ 9) 실험 제어, resetSim, exportCSV ------------------
  function nextExperiment() {
    currentExperimentIndex++;
    if(currentExperimentIndex >= experimentList.length){
      console.log("All experiments completed.");
      noLoop();
      return;
    }
    resetSimulation();
    applyExperimentParameters(currentExperimentIndex);
  }
  
  function applyExperimentParameters(index){
    let exp= experimentList[index];
    resolutionSlider.value(exp.res);
    algoSelect.value(exp.algo);
    currentAlgo= exp.algo;
    console.log(`Starting experiment #${index} => Resolution=${exp.res}, Algo=${exp.algo}`);
  }
  
  function resetSimulation() {
    dataLog= [];
    persistentPoints= [];
    sumSquaredError= 0;
    numErrorSamples= 0;
    frameCount= 0;
    avgFPS= 0;
    lastTime= performance.now();
  
    // window, warmup 재초기화
    for(let k in windowArrays){
      windowArrays[k]= [];
    }
    for(let k in warmupExpState){
      warmupExpState[k].frameCount=0;
      warmupExpState[k].expMeanSq=0;
    }
  
    robot= new Robot(width/4, height/2);
    startTime= millis();
    movePhase=0;
    phaseTime=0;
  }
  
  // CSV 12열
  function exportCSV() {
    let table= new p5.Table();
  
    table.addColumn("frame");
    table.addColumn("fps");
    table.addColumn("rmse");  // basic pos vs est
    table.addColumn("power");
    table.addColumn("resolution");
    table.addColumn("algo");
  
    table.addColumn("trueX");
    table.addColumn("trueY");
    table.addColumn("trueHeading");
    table.addColumn("estX");
    table.addColumn("estY");
    table.addColumn("headingError");
    table.addColumn("kfTraceP");
    table.addColumn("pfVariance");
    table.addColumn("icpPairCount");
  
    // 12개
    table.addColumn("dr_rmse_posHeading_window");
    table.addColumn("dr_rmse_posHeading_warmup");
    table.addColumn("dr_rmse_distanceRatio_window");
    table.addColumn("dr_rmse_distanceRatio_warmup");
  
    table.addColumn("kf_rmse_mahalanobis_window");
    table.addColumn("kf_rmse_mahalanobis_warmup");
  
    table.addColumn("pf_rmse_median_window");
    table.addColumn("pf_rmse_median_warmup");
    table.addColumn("pf_rmse_best_window");
    table.addColumn("pf_rmse_best_warmup");
  
    table.addColumn("icp_rmse_icpResidual_window");
    table.addColumn("icp_rmse_icpResidual_warmup");
  
    for(let i=0; i<dataLog.length; i++){
      let row= table.addRow();
      row.setString("frame", dataLog[i].frame);
      row.setString("fps", nf(dataLog[i].fps,2,2));
      row.setString("rmse", nf(dataLog[i].rmse,2,2));
      row.setString("power", nf(dataLog[i].power,2,2));
      row.setString("resolution", dataLog[i].resolution);
      row.setString("algo", dataLog[i].algo);
  
      row.setString("trueX", nf(dataLog[i].trueX,2,2));
      row.setString("trueY", nf(dataLog[i].trueY,2,2));
      row.setString("trueHeading", nf(dataLog[i].trueHeading,2,2));
      row.setString("estX", nf(dataLog[i].estX,2,2));
      row.setString("estY", nf(dataLog[i].estY,2,2));
      row.setString("headingError", nf(dataLog[i].headingError,2,2));
      row.setString("kfTraceP", nf(dataLog[i].kfTraceP,2,2));
      row.setString("pfVariance", nf(dataLog[i].pfVariance,2,2));
      row.setString("icpPairCount", dataLog[i].icpPairCount);
  
      row.setString("dr_rmse_posHeading_window", nf(dataLog[i].dr_rmse_posHeading_window,2,2));
      row.setString("dr_rmse_posHeading_warmup", nf(dataLog[i].dr_rmse_posHeading_warmup,2,2));
      row.setString("dr_rmse_distanceRatio_window", nf(dataLog[i].dr_rmse_distanceRatio_window,2,2));
      row.setString("dr_rmse_distanceRatio_warmup", nf(dataLog[i].dr_rmse_distanceRatio_warmup,2,2));
  
      row.setString("kf_rmse_mahalanobis_window", nf(dataLog[i].kf_rmse_mahalanobis_window,2,2));
      row.setString("kf_rmse_mahalanobis_warmup", nf(dataLog[i].kf_rmse_mahalanobis_warmup,2,2));
  
      row.setString("pf_rmse_median_window", nf(dataLog[i].pf_rmse_median_window,2,2));
      row.setString("pf_rmse_median_warmup", nf(dataLog[i].pf_rmse_median_warmup,2,2));
      row.setString("pf_rmse_best_window", nf(dataLog[i].pf_rmse_best_window,2,2));
      row.setString("pf_rmse_best_warmup", nf(dataLog[i].pf_rmse_best_warmup,2,2));
  
      row.setString("icp_rmse_icpResidual_window", nf(dataLog[i].icp_rmse_icpResidual_window,2,2));
      row.setString("icp_rmse_icpResidual_warmup", nf(dataLog[i].icp_rmse_icpResidual_warmup,2,2));
    }
  
    let expIndexStr= currentExperimentIndex.toString().padStart(2,'0');
    saveTable(table, "dataLog_"+expIndexStr+".csv", "csv");
}


//////////////////////////////////////////////////////////////////////////////////////////////////

// ------------------------------------------------------------
// Boundary, Ray (기존)
// ------------------------------------------------------------
class Boundary {
  constructor(x1,y1,x2,y2){
    this.a= createVector(x1,y1);
    this.b= createVector(x2,y2);
  }
  show(){
    stroke(255);
    line(this.a.x, this.a.y, this.b.x, this.b.y);
  }
}

class Ray {
  constructor(pos,angle){
    this.pos= pos;
    this.dir= p5.Vector.fromAngle(angle);
  }
  cast(wall,maxDist){
    const x1= wall.a.x, y1= wall.a.y;
    const x2= wall.b.x, y2= wall.b.y;
    const x3= this.pos.x, y3= this.pos.y;
    const x4= this.pos.x+ this.dir.x*maxDist, y4= this.pos.y+ this.dir.y*maxDist;

    const den= (x1-x2)*(y3-y4)- (y1-y2)*(x3-x4);
    if(den===0)return null;
    const t= ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/ den;
    const u= -((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))/ den;
    if(t>0 && t<1 && u>0 && u<1){
      const pt= createVector();
      pt.x= x1+ t*(x2-x1);
      pt.y= y1+ t*(y2-y1);
      return pt;
    }
    return null;
  }
}


// ------------------------------------------------------------
// Robot
//   (추가) DR 모션 노이즈, KF R=10, PF sensorSigma=10, ICP inlierThreshold=20
// ------------------------------------------------------------
class Robot {
  constructor(x,y){
    this.pos= createVector(x,y);
    this.rays= [];
    this.heading= 0;
    this.vel= createVector();
    this.maxDist= 150;
    this.colliding= false;

    // 추정 위치
    this.estimatedPos= createVector(x,y);

    // DR
    this.estimatedVel_DR= createVector(0,0);
    // DR 소량 노이즈
    this.drMotionNoise= 0.1;

    // PF
    this.particleCount= 1000;
    this.particles= null;

    // ICP
    this.lastScanPoints= [];
    this.tmpICPInlierCount= 0; // inlierCount 저장용

    // 충돌 회피용
    this.wallAvoidTimer= 0;

    // KF 
    this.kf= null;
  }

  update(deltaTimeMS){
    let dtSec= deltaTimeMS/1000;
    if(!isFinite(dtSec)|| dtSec<=0) dtSec= 0.016;

    // 회피
    if(this.wallAvoidTimer>0){
      this.heading+= 0.03;
      this.wallAvoidTimer--;
      this.updateRays();
      return;
    }

    let newPos= this.pos.copy();

    if(autoMove){
      phaseTime+= deltaTimeMS;
      if(movePhase===0){
        this.vel= p5.Vector.fromAngle(this.heading);
        this.vel.setMag(2);
        newPos.add(this.vel);
        if(phaseTime>2000){
          movePhase=1; phaseTime=0;
        }
      }
      else if(movePhase===1){
        this.heading-= 0.02;
        if(phaseTime>1000){
          movePhase=2; phaseTime=0;
        }
      }
      else if(movePhase===2){
        this.vel= p5.Vector.fromAngle(this.heading);
        this.vel.setMag(2);
        newPos.add(this.vel);
        if(phaseTime>2000){
          movePhase=0; phaseTime=0;
        }
      }
    } 
    else {
      if(keyIsDown(LEFT_ARROW)) this.heading-=0.03;
      else if(keyIsDown(RIGHT_ARROW)) this.heading+=0.03;
      if(keyIsDown(UP_ARROW)){
        this.vel= p5.Vector.fromAngle(this.heading);
        this.vel.setMag(2);
        newPos.add(this.vel);
      }
      else if(keyIsDown(DOWN_ARROW)){
        this.vel= p5.Vector.fromAngle(this.heading);
        this.vel.setMag(-2);
        newPos.add(this.vel);
      }
    }

    let coll= this.collide(newPos);
    if(coll){
      this.wallAvoidTimer=60;
    } else {
      this.pos= newPos;
    }
    this.updateRays();
  }

  updateRays(){
    this.rays= [];
    const resolution= resolutionSlider.value();
    for(let a=-PI/4; a<= PI/4; a+= radians(resolution)){
      this.rays.push( new Ray(this.pos, a+ this.heading) );
    }
  }

  updateEstimation(algoMode, deltaTimeMS, currentScan){
    let dt= deltaTimeMS/1000;
    if(!isFinite(dt)|| dt<=0) dt=0.016;

    switch(algoMode){
      case 'DR': {
        // DR+ 노이즈
        this.estimatedVel_DR= p5.Vector.fromAngle(this.heading);
        // 소량 노이즈
        this.estimatedVel_DR.setMag( 2 + randomGaussian(0,this.drMotionNoise) );
        this.estimatedPos.add( this.estimatedVel_DR.copy().mult(dt*60) );
        break;
      }


      case 'KF': {
        if (!this.kf) {
          this.kf = {
            x: this.estimatedPos.x,
            y: this.estimatedPos.y,
            theta: this.heading,
            P: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
          };
        }
        // Measurement noise (R)와 process noise (Q)는 튜닝 값
        let R_cov = [[10, 0], [0, 10]];
        let Q = [[0.1, 0, 0], [0, 0.1, 0], [0, 0, 0.05]];

        // 제어 입력: 키 상태로부터 선형 속도 v와 회전 속도 omega 결정
        let v = 0; 
        if (keyIsDown(UP_ARROW)) v = 2;
        else if (keyIsDown(DOWN_ARROW)) v = -2;
        let omega = 0;
        if (keyIsDown(LEFT_ARROW)) omega = -0.03;
        else if (keyIsDown(RIGHT_ARROW)) omega = 0.03;

        let th = this.kf.theta;
        let pred = {
          x: this.kf.x + v * dt * Math.cos(th),
          y: this.kf.y + v * dt * Math.sin(th),
          theta: th + omega * dt
        };

        // 상태 전파 행렬 A (선형화)
        let A = [
          [1, 0, -v * dt * Math.sin(th)],
          [0, 1,  v * dt * Math.cos(th)],
          [0, 0, 1]
        ];

        // 예측 공분산: P_pred = A * P * A^T + Q
        let AP = matMul(A, this.kf.P);
        let P_pred = matAdd(matMul(AP, matTranspose(A)), Q);

        // 관측 단계: 현재 스캔의 centroid (x,y) 계산
        let z = null;
        if (currentScan && currentScan.length > 0) {
          let sX = 0, sY = 0;
          for (let c of currentScan) {
            sX += c.x;
            sY += c.y;
          }
          let n = currentScan.length;
          z = { x: sX / n, y: sY / n };
        }

        if (z) {
          let H = [[1, 0, 0], [0, 1, 0]];  // 관측 행렬: 상태에서 x,y만 관측
          // 혁신: 실제 측정 z와 예측치 H*pred의 차이
          let hx = [pred.x, pred.y];
          let inno = { x: z.x - hx[0], y: z.y - hx[1] };

          // S = H * P_pred * H^T + R
          let HP = matMul(H, P_pred); // 2x3
          let S_2x2 = matMul(HP, matTranspose(H));  // 2x2
          S_2x2[0][0] += R_cov[0][0];
          S_2x2[0][1] += R_cov[0][1];
          S_2x2[1][0] += R_cov[1][0];
          S_2x2[1][1] += R_cov[1][1];
          let detS = S_2x2[0][0] * S_2x2[1][1] - S_2x2[0][1] * S_2x2[1][0];
          if (Math.abs(detS) < 1e-9) detS = 1e-9;
          let invS = [
            [ S_2x2[1][1] / detS, -S_2x2[0][1] / detS ],
            [ -S_2x2[1][0] / detS, S_2x2[0][0] / detS ]
          ];
          // Kalman Gain: K = P_pred * H^T * inv(S)
          let PHt = matMul(P_pred, matTranspose(H)); // 3x2
          let K = matMul(PHt, invS); // 3x2

          // KF 상태 업데이트
          let upd = {
            x: pred.x + (K[0][0] * inno.x + K[0][1] * inno.y),
            y: pred.y + (K[1][0] * inno.x + K[1][1] * inno.y),
            theta: pred.theta  // 측정이 없으므로 theta는 예측값 유지
          };

          // Joseph form을 이용한 공분산 업데이트:  
          //   newP = (I - K*H)*P_pred*(I - K*H)^T + K*R*K^T
          let I3 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
          let KH = matMul(K, H);  // 3x3
          let I_minus_KH = matSub(I3, KH);
          let P_temp = matMul(I_minus_KH, P_pred);
          let newP = matAdd(matMul(P_temp, matTranspose(I_minus_KH)), matMul(matMul(K, R_cov), matTranspose(K)));

          this.kf.x = upd.x;
          this.kf.y = upd.y;
          this.kf.theta = upd.theta;
          this.kf.P = newP;
        } else {
          this.kf.x = pred.x;
          this.kf.y = pred.y;
          this.kf.theta = pred.theta;
          this.kf.P = P_pred;
        }
        this.estimatedPos.x = this.kf.x;
        this.estimatedPos.y = this.kf.y;
        break;
     }





    //   case 'KF': {
    //     if(!this.kf){
    //       this.kf= {
    //         x: this.estimatedPos.x,
    //         y: this.estimatedPos.y,
    //         theta: this.heading,
    //         P: [[1,0,0],[0,1,0],[0,0,1]]
    //       };
    //     }
    //     // R=10
    //     let R_cov= [[10,0],[0,10]];
    //     let Q= [[0.1,0,0],[0,0.1,0],[0,0,0.05]];
        
    //     // 제어 입력
    //     let v=0; if(keyIsDown(UP_ARROW))v=2; else if(keyIsDown(DOWN_ARROW))v=-2;
    //     let omega=0; if(keyIsDown(LEFT_ARROW))omega=-0.03; else if(keyIsDown(RIGHT_ARROW))omega=0.03;

    //     let th= this.kf.theta;
    //     let pred= {
    //       x: this.kf.x + v*dt* Math.cos(th),
    //       y: this.kf.y + v*dt* Math.sin(th),
    //       theta: th + omega*dt
    //     };

    //     let A= [
    //       [1,0, -v*dt* Math.sin(th)],
    //       [0,1,  v*dt* Math.cos(th)],
    //       [0,0,1]
    //     ];

    //     // P_pred
    //     let AP= matMul(A, this.kf.P);
    //     let P_pred= matAdd( matMul(AP, matTranspose(A)), Q);

    //     // 관측
    //     let z=null;
    //     if(currentScan && currentScan.length>0){
    //       let sX=0,sY=0;
    //       for(let c of currentScan){ sX+=c.x; sY+=c.y; }
    //       let n= currentScan.length;
    //       z= {x: sX/n, y: sY/n};
    //     }
    //     if(z){
    //       let H= [[1,0,0],[0,1,0]];
    //       // 혁신
    //       let hx= [pred.x, pred.y];
    //       let inno= { x: z.x- hx[0], y: z.y- hx[1] };
    //       // S
    //       let HP= matMul(H, P_pred); //2x3
    //       let S_2x2= matMul(HP, matTranspose(H));
    //       S_2x2[0][0]+= R_cov[0][0];
    //       S_2x2[0][1]+= R_cov[0][1];
    //       S_2x2[1][0]+= R_cov[1][0];
    //       S_2x2[1][1]+= R_cov[1][1];
    //       let detS= S_2x2[0][0]* S_2x2[1][1]- S_2x2[0][1]* S_2x2[1][0];
    //       if(Math.abs(detS)<1e-9) detS=1e-9;
    //       let invS= [
    //         [ S_2x2[1][1]/detS, -S_2x2[0][1]/detS ],
    //         [ -S_2x2[1][0]/detS, S_2x2[0][0]/detS ]
    //       ];
    //       // K
    //       let PHt= matMul(P_pred, matTranspose(H)); // 3x2
    //       let K= matMul(PHt, invS); // 3x2

    //       let upd= {
    //         x: pred.x + (K[0][0]* inno.x + K[0][1]* inno.y),
    //         y: pred.y + (K[1][0]* inno.x + K[1][1]* inno.y),
    //         theta: pred.theta
    //       };
    //       // P
    //       let KH= matMul(K,H); //3x3
    //       let I3= [[1,0,0],[0,1,0],[0,0,1]];
    //       let I_KH= matSub(I3, KH);
    //       let newP= matMul(I_KH, P_pred);

    //       this.kf.x= upd.x; this.kf.y= upd.y; this.kf.theta= upd.theta;
    //       this.kf.P= newP;
    //     } else {
    //       this.kf.x= pred.x; this.kf.y= pred.y; this.kf.theta= pred.theta;
    //       this.kf.P= P_pred;
    //     }
    //     this.estimatedPos.x= this.kf.x;
    //     this.estimatedPos.y= this.kf.y;
    //     break;
    //   }


      case 'PF': {
        if(!this.particles){
          this.particles= [];
          for(let i=0;i<this.particleCount;i++){
            this.particles.push({
              x: this.estimatedPos.x,
              y: this.estimatedPos.y,
              theta: this.heading,
              weight:1.0
            });
          }
        }
        // sensorSigma=10
        let sensorSigma=10;

        let v=0; if(keyIsDown(UP_ARROW)) v=2; else if(keyIsDown(DOWN_ARROW)) v=-2;
        let omega=0; if(keyIsDown(LEFT_ARROW)) omega=-0.03; else if(keyIsDown(RIGHT_ARROW)) omega=0.03;
        let dtSec= dt;
        if(!isFinite(dtSec)|| dtSec<=0) dtSec=0.016;

        const motionNoiseTrans=0.5, motionNoiseRot=0.01;
        for(let p of this.particles){
          p.theta+= omega*dtSec + randomGaussian(0,motionNoiseRot);
          p.x+= v*dtSec* Math.cos(p.theta) + randomGaussian(0,motionNoiseTrans);
          p.y+= v*dtSec* Math.sin(p.theta) + randomGaussian(0,motionNoiseTrans);
        }

        if(!currentScan|| currentScan.length<1) break;
        let sX=0,sY=0;
        for(let c of currentScan){ sX+= c.x; sY+= c.y; }
        let n= currentScan.length;
        let actualC= {x: sX/n, y: sY/n};

        const maxDist=150;
        function simScan(par){
          let sc=[];
          let numSamples=3;
          for(let i=0;i<numSamples;i++){
            let a= -PI/4 + i*((PI/2)/(numSamples-1));
            let rAng= par.theta+ a;
            let rOri= createVector(par.x,par.y);
            let rDir= p5.Vector.fromAngle(rAng);
            let rec= maxDist; let best=null;
            for(let w of walls){
              const pt= castRayQuick(rOri,rDir,w,maxDist);
              if(pt){
                let dd= p5.Vector.dist(rOri,pt);
                if(dd<rec){
                  rec= dd; best= pt;
                }
              }
            }
            if(best) sc.push(best);
            else {
              sc.push(createVector(rOri.x+ rDir.x*maxDist, rOri.y+ rDir.y*maxDist));
            }
          }
          return sc;
        }

        let wSum=0;
        for(let p of this.particles){
          let scn= simScan(p);
          let sx=0, sy=0;
          for(let s of scn){ sx+= s.x; sy+= s.y; }
          let c= {x: sx/scn.length, y: sy/scn.length};
          let e= dist(c.x, c.y, actualC.x, actualC.y);
          let w= Math.exp( - (e*e)/(2* sensorSigma* sensorSigma) );
          p.weight= w; wSum+= w;
        }
        if(wSum===0){
          for(let p of this.particles){
            p.weight= 1.0/ this.particles.length;
          }
        } else {
          for(let p of this.particles){
            p.weight/= wSum;
          }
        }

        // 리샘플
        let newP= [];
        let cumsum=[];
        let c=0; 
        for(let p of this.particles){
          c+= p.weight; cumsum.push(c);
        }
        let start= random(0,1/this.particles.length);
        let idx=0, N= this.particles.length;
        for(let i=0;i<N;i++){
          let pos= start+ i/N;
          while(pos> cumsum[idx]) idx++;
          newP.push({
            x:this.particles[idx].x,
            y:this.particles[idx].y,
            theta:this.particles[idx].theta,
            weight:1.0
          });
        }
        this.particles= newP;

        // 평균
        let mx=0, my=0;
        for(let p of this.particles){ mx+= p.x; my+= p.y; }
        mx/= this.particles.length; 
        my/= this.particles.length;
        this.estimatedPos.x= lerp(this.estimatedPos.x,mx,0.1);
        this.estimatedPos.y= lerp(this.estimatedPos.y,my,0.1);
        break;
      }





      case 'ICP/GraphSLAM': {
        // inlierThreshold (픽셀 단위)
        let inlierThreshold = 20;
        if (this.lastScanPoints.length < 5 || !currentScan || currentScan.length < 5) break;
        
        // 1) 모든 현재 스캔 점에 대해, 가장 가까운 이전 스캔 점을 찾고, inlier 조건(오차 < inlierThreshold)을 만족하는 쌍을 저장
        let pairs = [];
        for (let pNow of currentScan) {
          let bestDist = Infinity;
          let bestPt = null;
          for (let pOld of this.lastScanPoints) {
            let dd = p5.Vector.dist(pNow, pOld);
            if (dd < bestDist) {
              bestDist = dd;
              bestPt = pOld;
            }
          }
          if (bestDist < inlierThreshold) {
            pairs.push({ now: pNow, old: bestPt });
          }
        }
        if (pairs.length < 5) break;
        
        // 2) RANSAC 기반으로 초기 후보 변환 (회전 및 translation) 추정
        let bestInlierCount = 0;
        let bestCandidate = null;
        const iterations = 10;
        for (let iter = 0; iter < iterations; iter++) {
          // 랜덤하게 2개의 서로 다른 매칭 쌍 선택
          let idx1 = floor(random(pairs.length));
          let idx2 = floor(random(pairs.length));
          if (idx1 === idx2) continue;
          let sample1 = pairs[idx1];
          let sample2 = pairs[idx2];
          
          // 선택된 두 쌍의 현재 스캔 점과 이전 스캔 점의 중심(centroid) 계산
          let centroidNow = createVector((sample1.now.x + sample2.now.x) / 2, (sample1.now.y + sample2.now.y) / 2);
          let centroidOld = createVector((sample1.old.x + sample2.old.x) / 2, (sample1.old.y + sample2.old.y) / 2);
          
          // 한 쌍의 차이를 이용하여 회전각 후보 계산
          let vecNow = p5.Vector.sub(sample1.now, centroidNow);
          let vecOld = p5.Vector.sub(sample1.old, centroidOld);
          let thetaCandidate = Math.atan2(vecNow.y, vecNow.x) - Math.atan2(vecOld.y, vecOld.x);
          
          // 이전 중심(centroid)을 회전시키고 translation 후보 계산
          let cosT = Math.cos(thetaCandidate), sinT = Math.sin(thetaCandidate);
          let rotatedOldCentroid = createVector(
            cosT * centroidOld.x - sinT * centroidOld.y,
            sinT * centroidOld.x + cosT * centroidOld.y
          );
          let translationCandidate = p5.Vector.sub(centroidNow, rotatedOldCentroid);
          
          // 이 후보 변환을 모든 쌍에 적용하여 inlier 수 계산
          let inlierCount = 0;
          for (let pair of pairs) {
            let transformed = createVector(
              cosT * pair.old.x - sinT * pair.old.y + translationCandidate.x,
              sinT * pair.old.x + cosT * pair.old.y + translationCandidate.y
            );
            let error = p5.Vector.dist(transformed, pair.now);
            if (error < inlierThreshold) {
              inlierCount++;
            }
          }
          if (inlierCount > bestInlierCount) {
            bestInlierCount = inlierCount;
            bestCandidate = { theta: thetaCandidate, translation: translationCandidate.copy() };
          }
        }
        
        // 3) 후보 변환(bestCandidate)을 기반으로 inlier들을 다시 선택한 후, SVD(유사한) 방식으로 정밀 보정 수행
        if (bestCandidate) {
          let cosT = Math.cos(bestCandidate.theta), sinT = Math.sin(bestCandidate.theta);
          let inliers = [];
          for (let pair of pairs) {
            let transformed = createVector(
              cosT * pair.old.x - sinT * pair.old.y + bestCandidate.translation.x,
              sinT * pair.old.x + cosT * pair.old.y + bestCandidate.translation.y
            );
            let error = p5.Vector.dist(transformed, pair.now);
            if (error < inlierThreshold) {
              inliers.push(pair);
            }
          }
          
          if (inliers.length >= 5) {
            // 모든 inlier 쌍에 대해 중심 계산
            let centroidNow = createVector(0, 0);
            let centroidOld = createVector(0, 0);
            for (let pair of inliers) {
              centroidNow.add(pair.now);
              centroidOld.add(pair.old);
            }
            centroidNow.div(inliers.length);
            centroidOld.div(inliers.length);
            
            // 공분산 행렬 계산
            let M11 = 0, M12 = 0, M21 = 0, M22 = 0;
            for (let pair of inliers) {
              let diffNow = p5.Vector.sub(pair.now, centroidNow);
              let diffOld = p5.Vector.sub(pair.old, centroidOld);
              M11 += diffNow.x * diffOld.x;
              M12 += diffNow.x * diffOld.y;
              M21 += diffNow.y * diffOld.x;
              M22 += diffNow.y * diffOld.y;
            }
            // 회전각 추정 (ICP 2D 공식)
            let refinedTheta = Math.atan2(M21 - M12, M11 + M22);
            
            // 정밀 translation 계산: 이전 중심을 회전시켜 현재 중심과의 차이
            let cosRef = Math.cos(refinedTheta), sinRef = Math.sin(refinedTheta);
            let rotatedOldCentroid = createVector(
              cosRef * centroidOld.x - sinRef * centroidOld.y,
              sinRef * centroidOld.x + cosRef * centroidOld.y
            );
            let refinedTranslation = p5.Vector.sub(centroidNow, rotatedOldCentroid);
            
            // 적용: refined transformation을 현재 상태에 적용
            this.heading += refinedTheta;
            this.estimatedPos.x += refinedTranslation.x;
            this.estimatedPos.y += refinedTranslation.y;
          }
        }
        break;
      }

    }
    if(currentScan&& currentScan.length>0){
      this.lastScanPoints= currentScan.slice();
    }
  }

  collide(newPos){
    for(let w of walls){
      let d= distToSegment(newPos, w.a, w.b);
      if(d<10) return true;
    }
    return false;
  }

  look(walls){
    stroke(100,255,100,80);
    let pts= [];
    for(let ray of this.rays){
      let closest=null; let record= this.maxDist;
      for(let w of walls){
        let pt= ray.cast(w, this.maxDist);
        if(pt){
          let dd= p5.Vector.dist(this.pos, pt);
          if(dd< record){
            record= dd; closest= pt;
          }
        }
      }
      line(
        this.pos.x, this.pos.y,
        closest? closest.x: ray.pos.x+ ray.dir.x*this.maxDist,
        closest? closest.y: ray.pos.y+ ray.dir.y*this.maxDist
      );
      if(closest) pts.push(closest);
    }
    return pts;
  }

  show(){
    fill(this.colliding? 'red': 'white');
    ellipse(this.pos.x, this.pos.y, 12);
    stroke(255); strokeWeight(2);
    line(
      this.pos.x, this.pos.y,
      this.pos.x+ Math.cos(this.heading)*20,
      this.pos.y+ Math.sin(this.heading)*20
    );

    // 추정 (파랑)
    push();
    fill(0,100,255,180);
    noStroke();
    ellipse(this.estimatedPos.x, this.estimatedPos.y, 8);
    pop();
  }
}

// PF 내부용
function castRayQuick(origin, dir, wall, maxDist){
  const x1=wall.a.x, y1=wall.a.y;
  const x2=wall.b.x, y2=wall.b.y;
  const x3= origin.x, y3= origin.y;
  const x4= origin.x+ dir.x* maxDist, y4= origin.y+ dir.y* maxDist;

  const den= (x1-x2)*(y3-y4)- (y1-y2)*(x3-x4);
  if(den===0) return null;
  const t= ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/ den;
  const u= -((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))/ den;
  if(t>0 && t<1 && u>0 && u<1){
    let px= x1+ t*(x2-x1);
    let py= y1+ t*(y2-y1);
    return createVector(px,py);
  }
  return null;
}

// KF용
function matMul(A,B){
  let m= A.length, n= A[0].length, p= B[0].length;
  let C= new Array(m).fill(0).map(()=> new Array(p).fill(0));
  for(let i=0;i<m;i++){
    for(let j=0;j<p;j++){
      let sum=0;
      for(let k=0;k<n;k++){
        sum+= A[i][k]* B[k][j];
      }
      C[i][j]= sum;
    }
  }
  return C;
}
function matAdd(A,B){
  let r= A.length, c= A[0].length;
  let R= new Array(r).fill(0).map(()=> new Array(c).fill(0));
  for(let i=0;i<r;i++){
    for(let j=0;j<c;j++){
      R[i][j]= A[i][j]+ B[i][j];
    }
  }
  return R;
}
function matSub(A,B){
  let r= A.length, c= A[0].length;
  let R= new Array(r).fill(0).map(()=> new Array(c).fill(0));
  for(let i=0;i<r;i++){
    for(let j=0;j<c;j++){
      R[i][j]= A[i][j]- B[i][j];
    }
  }
  return R;
}
function matTranspose(A){
  let r= A.length, c= A[0].length;
  let R= new Array(c).fill(0).map(()=> new Array(r).fill(0));
  for(let i=0;i<r;i++){
    for(let j=0;j<c;j++){
      R[j][i]= A[i][j];
    }
  }
  return R;
}
function distToSegment(p, v, w){
  const l2= p5.Vector.dist(v,w)**2;
  if(l2===0) return p5.Vector.dist(p,v);
  let t= max(0, min(1, ((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/ l2));
  let proj= createVector(v.x+ t*(w.x-v.x), v.y+ t*(w.y-v.y));
  return p5.Vector.dist(p, proj);
}

